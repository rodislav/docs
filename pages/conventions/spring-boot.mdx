---
title: 'Spring Boot'
description: 'Coding conventions for **Spring Boot** based applications'
---

<Info>
  **Note**: This document outlines the coding conventions when using Spring Boot framework.
</Info>

# Framework

- Use latest stable version of Spring Boot.
- Generate a banner with the name of the application.

- Use constructor-based dependency injection.
- Do not use field dependency injection.
- Do not use `@Autowired` annotation for dependency injection.

- Avoid using `@ComponentScan` annotation, unless absolutely necessary.

- Use `.properties` files for configuration, not `application.yml` nor `application.yaml` files.
- Use `@Configuration` for configuration classes.
- Do not use `@Value` annotation for injecting configuration properties, instead use `@ConfigurationProperties` for binding configuration properties to classes which are used via constructor injection.
- Use spring configuration processing features like `@ConfigurationProperties` for binding configuration properties to classes and generate properties files for auto-completion.

- Use **MapStruct** for mapping operations.
- Use **JSpecify** annotations for type safety.

- Use `lombok` for reducing boilerplate code.
- Create `lombok.config` file in the root of the project with the following content:
    ```properties
    lombok.accessors.chain=true
    lombok.addLombokGeneratedAnnotation = true
    ```

- Use `liquibase` for SQL migrations. Write migrations in SQL format, not XML nor YAML.

- Use `springdoc-openapi` for documenting APIs and DTOs.
- Use `spring-boot-starter-test` for unit testing.
- Use `spring-boot-starter-actuator` for monitoring and management.
- Use `spring-boot-devtools` for hot-reloading.
- Use `spring-boot-starter-security` for authentication and authorization.
- Use `spring-boot-starter-validation` for validation.
- Use `spring-boot-starter-data-jpa` for JPA.
- Use `spring-boot-starter-web` for web APIs.

# Project Structure

## Package Organization

- Use technical layers to structure your code in packages:
    - `api` layer for API endpoints, controllers, DTOs, and API-specific exceptions.
    - `domain` layer for business logic, entities, domain services, and domain exceptions.
    - `application` layer for application services, use cases, and orchestration logic.
    - `infrastructure` layer for technical details, external integrations, and framework configurations.
    - `shared` layer for common utilities, validation, and cross-cutting concerns.

## Example Structure

```
src/main/java/com/company/project/
├── Application.java                 // Main class
├── api/                            // Controllers and DTOs
│   ├── controller/
│   │   ├── UserController.java
│   │   └── OrderController.java
│   ├── dto/
│   │   ├── CreateUserDTO.java
│   │   ├── UserDTO.java
│   │   ├── CreateOrderDTO.java
│   │   ├── OrderDTO.java
│   └── exception/
│       └── GlobalExceptionHandler.java
├── domain/                         // Business logic
│   ├── model/
│   │   ├── User.java
│   │   └── Order.java
│   ├── service/
│   │   ├── UserService.java
│   │   └── OrderService.java
├── infrastructure/                 // Technical concerns
│   ├── config/
│   │   ├── SecurityConfig.java
│   │   └── DatabaseConfig.java
│   ├── persistence/
│   │   └── repository/
│   │       ├── UserRepository.java
│   │       └── OrderRepository.java
│   │   └── entity/
│   │       ├── UserEntity.java
│   │       └── OrderEntity.java
│   └── external/
│       └── client/
└── shared/                         // Common utilities
    ├── exception/
    ├── validation/
    └── util/
```

# Naming

- Controllers: `{Entity}Controller` (e.g., `UserController`)
- Services: `{Entity}Service` (e.g., `UserService`)
- Repositories: `{Entity}Repository` (e.g., `UserRepository`)
- DTOs: `{Action}{Entity}DTO` (e.g., `CreateUserDTO`)
- JPA Entities: `{Entity}Entity` (e.g., `UserEntity`)
- Exceptions: `{Entity}{ErrorType}Exception` (e.g., `UserNotFoundException`)
- Constraint: `{Check}{Entity}Constraint` (e.g., `UniqueEmailConstraint`)

# Hierarchy

- **Controllers** shall use a "Services" to handle the business logic.
- **Controllers** are mapping entities to DTOs.
- **Controllers** shall never call "Repositories".
- **Services** shall call directly: **Repositories**, **Helpers**, and other components.
- **Services** are not mapping entities to DTOs.
- Other components like **ConstraintValidator** or **UserService** can call **Repositories** directly, if needed. 
- Put the **Spring Security** configuration annotations at the **Controller** level or at the **Service** level.

## Controllers

- Use `@RestController` annotation for controllers.
- Favor `@GetMapping`, `@PostMapping`, `@PutMapping`, `@PatchMapping`, `@DeleteMapping` annotations for mapping HTTP methods.
- Use `@RequestParam` annotation for mapping request parameters.
- Use `@Valid` annotation for validating request bodies.
- Use `@Validated` annotation for validating request bodies and request parameters.
- Use **DTOs** for data transfer objects and **lombok**, to reduce the boilerplate code.
- DTOs are using `@Data` annotation for reducing boilerplate code. 
- DTOs are part of the "*API layer*".
- Do not use `ResponseEntity` for returning responses, unless absolutely necessary.
- Inject the `WebRequest request` to the corresponding controller method, instead of using `HttpServletRequest` or `HttpServletResponse`.
- The Controller methods shall not have any business logic, they shall only delegate the calls to the service layer.
    - Example: if a check is required to be done before calling the service, it shall be done in the service layer, not in the controller.
- Use pagination for listing collections of resources, even if the initial implementation does not require it. 
- Use `Pageable` interface for pagination.
- Use `Page<T>` interface for returning paginated results.
- Default page size shall be 20 items.
- Maximum page size shall be 100 items.

## Service Layer

- Use `@Transactional` annotation only if it is required and only in the classes annotated with `@Service` annotation.

## JPA Entities

- Use `@Entity` annotation for JPA entities.
- Use `@Id` annotation for the primary key.
- Use `@GeneratedValue` annotation for primary key generation.
- Use `@Column` annotation for columns.
- Use `@Table` annotation for tables.
- Use `@OneToMany` annotation for one-to-many relationships.
- Use `@ManyToOne` annotation for many-to-one relationships.
- Use `@JoinColumn` annotation for joining columns.
- Use `@Transient` annotation for transient fields.
- Use `@SequenceGenerator` annotation for sequence generators.
- For complex primary keys, use composite keys.
- Avoid using entity relationships, instead use IDs to link entities, including for collections.
- Use suffix `Entity` for entity classes.
- When an `Entity` has a field annotated with `@Column(updatable = false)` or `@Column(insertable = false)`, use `@Setter(AccessLevel.PROTECTED)` to avoid generating setters for those fields.
- Use `@Getter` and `@Setter` annotations instead of `@Data` annotation.
- Favor IDs of type `Long` for primary keys.

# Validation and Annotations

## DTO Validation
```java
@NoArgsConstructor
@Data
public class CreateUserDTO {
    @NotBlank(message = "Street is required and cannot be empty")
    @Size(max = 100, message = "Name cannot exceed 100 characters")
    String name;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Email cannot be empty")
    String email;
    
    @NotNull(message = "Age is required")
    @Min(value = 18, message = "Age must be at least 18")
    @Max(value = 120, message = "Age must not exceed 120")
    Integer age;
    
    @Valid
    @NotNull(message = "Address is required")
    AddressRequest address;
}

@NoArgsConstructor
@Data
public class CreateAddressDTO {
    @NotBlank(message = "Street is required and cannot be empty")
    String street;
    
    @NotBlank(message = "City is required and cannot be empty")
    String city;
    
    @Pattern(regexp = "^\\d{5}(-\\d{4})?$", message = "ZIP code must use this format: 12345 or 12345-6789")
    String zipCode;
}
```

## Custom Validation

- When validating, make sure to not expose sensitive information in the validation messages like "email already exists", instead use a generic message like "this email cannot be used".

```java
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = UniqueEmailValidator.class)
public @interface UniqueEmailConstraint {
    String message() default "This email cannot be used";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

@Component
public class UniqueEmailValidator implements ConstraintValidator<UniqueEmail, String> {
    
    private final UserRepository userRepository;
    
    public UniqueEmailValidator(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Override
    public boolean isValid(String email, ConstraintValidatorContext context) {
        return email != null && !userRepository.existsByEmail(email);
    }
}

@NoArgsConstructor
@Data
public class CreateUserDTO {

    @UniqueEmailConstraint
    String email;
}

```

# Exceptions

- Use `org.springframework.web.bind.annotation.ResponseStatus` annotation for mapping HTTP status codes to exceptions.
- Generate exceptions for generic cases like: Not Found, Bad Request, etc.
- Use `org.springframework.http.HttpStatus` for HTTP status codes.

# Logging

- Use `org.slf4j.Logger` for logging.
- Use `org.slf4j.LoggerFactory` for creating loggers.
- Use `org.slf4j.MDC` for logging context.

# SQL Database

- Use the name of the user as the name of the schema.
- The default password for the user should be `password`.
- Use `org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate` for executing SQL queries.
- Avoid using `org.springframework.jdbc.core.JdbcTemplate` for executing SQL queries, unless absolutely necessary.

# Testing

- Use `@SpringBootTest` annotation for integration tests.
- Use `@TestPropertySource` annotation for loading test properties.
- Use `@MockBean` annotation for mocking beans.

- Example of a unit test for a service class using Spring Boot Test and Mockito:
```java
@SpringBootTest
@TestPropertySource(locations = "classpath:application-test.properties")
class UserServiceTest {
    
    @MockBean
    private UserRepository userRepository;
    
    @Autowired
    private UserService userService;
    
    @Test
    void createUser_WithValidData_ReturnsUser() {
        // Given
        var request = new CreateUserRequest("John Doe", "john@example.com", null);
        var expectedUser = User.builder()
            .id(1L)
            .name("John Doe")
            .email("john@example.com")
            .build();
            
        when(userRepository.save(any(User.class))).thenReturn(expectedUser);
        
        // When
        var result = userService.createUser(request);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getName()).isEqualTo("John Doe");
        assertThat(result.getEmail()).isEqualTo("john@example.com");
    }
}
```

# Maven

- Use JIB for building OCI images.

- Use the `git-commit-id-plugin` for generating commit IDS.
    - https://github.com/git-commit-id/git-commit-id-maven-plugin
    - Example:
    - ```xml
        <plugin>
            <groupId>io.github.git-commit-id</groupId>
                <artifactId>git-commit-id-maven-plugin</artifactId>
                <version>9.0.2</version>
                <executions>
                <execution>
                    <id>get-the-git-infos</id>
                    <goals>
                        <goal>revision</goal>
                    </goals>
                    <phase>initialize</phase>
                </execution>
            </executions>
                <configuration>
                <generateGitPropertiesFile>true</generateGitPropertiesFile>
                <generateGitPropertiesFilename>${project.build.outputDirectory}/git.properties</generateGitPropertiesFilename>
                <commitIdGenerationMode>full</commitIdGenerationMode>
            </configuration>
        </plugin>
      ```

- Use `springdoc-openapi-maven-plugin` to generate the OpenAPI documentation:
    - https://github.com/springdoc/springdoc-openapi-maven-plugin
    - Example:
    ```xml
        <plugin>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-maven-plugin</artifactId>
            <version>1.5</version>
            <executions>
                <execution>
                    <id>integration-test</id>
                    <goals>
                        <goal>generate</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    ```

- Use the following order of `annotationProcessorPaths` in `maven-compiler-plugin` configuration, 
    - Example:
    ```xml
    <annotationProcessorPaths>
        <path>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
        </path>
        <path>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok-mapstruct-binding</artifactId>
            <version>0.2.0</version>
        </path>
        <path>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct-processor</artifactId>
            <version>${mapstruct.version}</version>
        </path>
        <path>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <version>${spring-boot.version}</version>
        </path>
    </annotationProcessorPaths>
    ```

- Use Automatic Property Expansion:
    - Eample for `application.properties` file:
    ```properties
        app.encoding=@project.build.sourceEncoding@
        app.java.version=@java.version@
    ```

    - Example in the banner file:
    ```text
    ${app.name} - App Version ${app.version} - Encoding ${app.encoding} - Java Version ${app.java.version}
    ```

    - Example for `pom.xml` file:
    ```xml
        <build>
            <resources>
                <resource>
                    <directory>src/main/resources</directory>
                    <filtering>true</filtering>
                </resource>
            </resources>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-resources-plugin</artifactId>
                    <version>2.7</version>
                    <configuration>
                    <delimiters>
                        <delimiter>@</delimiter>
                    </delimiters>
                    <useDefaultDelimiters>false</useDefaultDelimiters>
                </configuration>
            </plugin>
        </build>
    ```
