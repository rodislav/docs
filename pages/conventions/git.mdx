---
title: 'Git'
description: 'Conventions for using git'
---

# Ignoring files

- If `.git` folder does not exist, run `git init` in the project root.
- Create `.gitignore` file at the root of the project.
- Include these entries by default:
    ```gitignore
    # Ignore build directories
    /build/
    /target/
    /dist/
    /out/
    
    # Ignore dependency directories
    node_modules/
    .pnp/
    .yarn/
    
    # Ignore IDE files
    .idea/
    .vscode/
    *.iml
    *.swp
    *.swo
    *~
    
    # Ignore logs
    *.log
    logs/
    
    # Ignore local stuff
    *-local*
    *.local.env
    *.local.md
    .env.local
    .env.*.local
    
    # Ignore OS-specific files
    .DS_Store
    .DS_Store?
    Thumbs.db
    ehthumbs.db
    Desktop.ini
    
    # Ignore temporary files
    *.tmp
    *.temp
    .cache/
    
    # Language-specific ignores
    __pycache__/
    *.pyc
    *.pyo
    *.class
    *.jar
    
    # Tool-specific ignores for LLM development
    .claude/
    .cursor/
    .aider*
    .copilot/
    ```

# Branching
- Use `main` as the default branch.
- Use **TBD Trunk-Based Development** branching strategy.
- Use feature branches for new features or bug fixes.
- Merge to `main` branch every day.
- Split changes into small commits.
- Always rebase before merging.
- Do not sync branches to environments.
    - Example: do not use a `dev` branch to sync to `dev` environment, or `uat` to `uat` environment.
- Releases are done from the `main` branch and are generating tags.
- Tags are corresponding to released versions.
- When a hotfix is required, do the following:
    - Create a branch from the tag that corresponds to the affected version with the name `hotfix/TAG-reason-for-hotfix`.
    - Then create a new release from this branch and a corresponding tag.
    - If the changes are deemed meaningful, merge them to `main` and delete the hotfix branch.
    - The merge operation can be a backporting or cherry-picking activity, if the changes are not straightforward.

# Commit Messages

Use conventional commit format for consistency and automation:

## Format
```
<type>(<scope>): <description>

[optional body]

[optional footer(s)]
```

## Types
- `feat`: new feature
- `fix`: bug fix
- `docs`: documentation changes
- `style`: formatting, missing semicolons, etc.
- `refactor`: code change that neither fixes a bug nor adds a feature
- `perf`: performance improvements
- `test`: adding or modifying tests
- `chore`: maintenance tasks, dependency updates
- `ci`: changes to CI/CD configuration
- `build`: changes to build system or external dependencies

## Examples
```
feat(auth): add OAuth2 integration

fix(api): handle null response in user service

docs: update installation guide

refactor(utils): simplify date formatting logic

chore: update dependencies to latest versions
```

## Guidelines for LLM Collaboration
- Keep subject line under 50 characters
- Use imperative mood ("add" not "added")
- Capitalize first letter of subject
- No period at end of subject line
- Separate subject from body with blank line
- Wrap body at 72 characters
- Use body to explain what and why, not how

# LLM-Specific Guidelines

## Working with AI Coding Tools

### Commit Attribution
When using LLM tools like Claude Code or Cursor, include attribution in commit messages:
```
feat(api): implement user authentication

Co-authored-by: Claude <noreply@anthropic.com>
ðŸ¤– Generated with Claude Code
```

### Before Committing
1. **Review all changes**: Never commit without understanding what was changed
2. **Run tests**: Ensure `npm test`, `mvn test`, or equivalent passes
3. **Run linters**: Use `npm run lint`, `ruff`, or project-specific linting
4. **Check build**: Verify `npm run build`, `mvn compile`, etc. succeeds
5. **Verify functionality**: Test the feature/fix manually if possible

### Staging Changes
- Use `git add -p` to review and stage changes interactively
- Stage related changes together in logical commits
- Separate refactoring from feature changes
- Keep commits atomic and focused

### Branch Management with LLMs
- Create feature branches for each distinct task: `git checkout -b feat/user-auth`
- Use descriptive branch names that match the feature being developed
- Push branches regularly: `git push -u origin feat/user-auth`
- Clean up merged branches: `git branch -d feat/user-auth`

# Pre-commit Hooks

Set up automated checks to maintain code quality:

## Setup
```bash
# Install pre-commit
pip install pre-commit
# or
npm install --save-dev pre-commit

# Install hooks
pre-commit install
```

## Common Hooks
Create `.pre-commit-config.yaml`:
```yaml
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.4.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-json
      - id: check-merge-conflict
      - id: check-added-large-files
        args: ['--maxkb=500']
  
  # Language-specific hooks
  - repo: https://github.com/psf/black
    rev: 22.3.0
    hooks:
      - id: black
        language_version: python3
  
  - repo: https://github.com/eslint/eslint
    rev: v8.0.0
    hooks:
      - id: eslint
        files: \.[jt]sx?$
```

# Conflict Resolution

## When Conflicts Arise
1. **Don't panic**: Conflicts are normal in collaborative development
2. **Understand the conflict**: Read both versions carefully
3. **Communicate**: Discuss with team members if unsure
4. **Test after resolution**: Ensure the merged code works correctly

## Resolution Process
```bash
# Pull latest changes
git pull origin main

# If conflicts occur during merge/rebase
# 1. Open conflicted files
# 2. Look for conflict markers: <<<<<<<, =======, >>>>>>>
# 3. Choose or combine the changes
# 4. Remove conflict markers
# 5. Test the resolution
# 6. Stage resolved files
git add .

# Complete the merge/rebase
git commit  # for merge
git rebase --continue  # for rebase
```

## Prevention
- Pull frequently: `git pull origin main`
- Keep branches short-lived (< 2 days)
- Communicate about overlapping work
- Use smaller, focused commits

# Collaboration Best Practices

## Code Reviews
- Request reviews for all non-trivial changes
- Provide constructive feedback
- Address all review comments before merging
- Use draft PRs for work-in-progress discussions

## Communication
- Use descriptive commit messages
- Link commits to issues/tickets when applicable
- Update documentation alongside code changes
- Notify team of breaking changes

## Repository Hygiene
- Clean up merged branches regularly
- Keep commit history clean with rebasing
- Tag releases consistently
- Archive or delete stale branches
