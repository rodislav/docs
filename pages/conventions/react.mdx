---
title: 'React'
description: 'Conventions for using React Framework for building Single Page Applications with LLM tools'
---

<Info>
  **Note**: This document outlines React conventions for building modern Single Page Applications, with specific guidelines for development using LLM tools like Claude Code and Cursor.
</Info>

# General Setup

- Use 4 spaces for indentation.
- Use one empty line before return statements, after imports, and between functions.
- Use double quotes for strings by default, single quotes for strings containing double quotes.

## Core Dependencies
- Use **React** with latest stable version
- Use **Vite** for fast development and building (do not use Create React App)
- Use **TypeScript** for type safety and better developer experience
- Use **@tanstack/react-query** (formerly React Query) for server state management
- Use **React Router** for routing
- Use **React Hook Form** for form handling with validation

## Development Tools
- Use **ESLint** and **Prettier** for code formatting and linting
- Use **Vitest** and **React Testing Library** for testing
- Use **Storybook** for component development and documentation
- Use **React DevTools** and **TanStack Query DevTools** for debugging

## Build and Tooling
```json
{
  "scripts": {
    "start": "vite",
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "lint": "eslint src --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "format": "prettier --write src/**/*.{ts,tsx,json,css,md}"
  }
}
```

# Project Structure

## Directory Organization
```
src/
├── components/          # Reusable UI components
│   ├── ui/              # Basic UI primitives (Button, Input, etc.)
│   ├── forms/           # Form-specific components
│   └── layout/          # Layout components (Header, Sidebar, etc.)
├── pages/               # Page-level components
│   ├── auth/            # Authentication pages
│   ├── dashboard/       # Dashboard pages
│   └── settings/        # Settings pages
├── hooks/               # Custom hooks
├── services/            # API services and external integrations
├── types/               # TypeScript type definitions
├── utils/               # Utility functions
├── stores/              # State management (if using Zustand/Context)
├── constants/           # Application constants
├── assets/              # Static assets (images, fonts, etc.)
└── styles/              # Global styles and themes
```

## File Naming Conventions
- **Components**: PascalCase (e.g., `UserProfile.tsx`)
- **Hooks**: camelCase starting with 'use' (e.g., `useUserData.ts`)
- **Utilities**: camelCase (e.g., `formatDate.ts`)
- **Types**: PascalCase (e.g., `User.types.ts`)
- **Constants**: UPPER_CASE (e.g., `API_ENDPOINTS.ts`)
- **Directories**: kebab-case (e.g., `user-profile/`)

## Component File Structure
```typescript
// UserProfile.tsx
import React from 'react';
import { useQuery } from '@tanstack/react-query';
import { userService } from '../services/userService';
import { User } from '../types/User.types';

interface UserProfileProps {
  userId: string;
  className?: string;
}

export const UserProfile: React.FC<UserProfileProps> = ({ 
  userId, 
  className 
}) => {
  // Component logic here
  
  return (
    <div className={className}>
      {/* JSX here */}
    </div>
  );
};

export default UserProfile;
```

# TypeScript Integration

## Type Definitions
```typescript
// types/User.types.ts
export interface User {
  id: string;
  name: string;
  email: string;
  avatar?: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateUserRequest {
  name: string;
  email: string;
}

export interface UpdateUserRequest extends Partial<CreateUserRequest> {
  id: string;
}

// API Response types
export interface ApiResponse<T> {
  data: T;
  message: string;
  success: boolean;
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    hasNext: boolean;
    hasPrevious: boolean;
  };
}
```

## Component Props Typing
```typescript
// Strict prop typing
interface ButtonProps {
  variant: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  loading?: boolean;
  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;
  children: React.ReactNode;
  className?: string;
  'data-testid'?: string;
}

// Generic component props
interface ListProps<T> {
  items: T[];
  renderItem: (item: T, index: number) => React.ReactNode;
  keyExtractor: (item: T) => string | number;
  loading?: boolean;
  emptyMessage?: string;
}

// Form handling props
interface FormProps<T> {
  initialValues?: Partial<T>;
  onSubmit: (values: T) => Promise<void> | void;
  validationSchema?: any; // Yup or Zod schema
  children: React.ReactNode;
}
```

## Hook Typing
```typescript
// Custom hook with proper typing
interface UseUserDataReturn {
  user: User | null;
  loading: boolean;
  error: Error | null;
  refetch: () => void;
}

export const useUserData = (userId: string): UseUserDataReturn => {
  const { data: user, isLoading: loading, error, refetch } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => userService.getUser(userId),
    enabled: !!userId,
  });

  return {
    user: user || null,
    loading,
    error: error as Error | null,
    refetch,
  };
};
```

# Component Patterns

## Functional Components with Hooks
```typescript
// Good: Modern functional component
export const UserList: React.FC = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedUsers, setSelectedUsers] = useState<string[]>([]);
  
  const { 
    data: users, 
    isLoading, 
    error 
  } = useQuery({
    queryKey: ['users', searchTerm],
    queryFn: () => userService.getUsers({ search: searchTerm }),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });

  const handleUserSelect = useCallback((userId: string) => {
    setSelectedUsers(prev => 
      prev.includes(userId) 
        ? prev.filter(id => id !== userId)
        : [...prev, userId]
    );
  }, []);

  const filteredUsers = useMemo(() => {
    if (!users || !searchTerm) return users;
    return users.filter(user => 
      user.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [users, searchTerm]);

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  if (!filteredUsers?.length) return <EmptyState message="No users found" />;

  return (
    <div className="user-list">
      <SearchInput 
        value={searchTerm}
        onChange={setSearchTerm}
        placeholder="Search users..."
      />
      {filteredUsers.map(user => (
        <UserCard
          key={user.id}
          user={user}
          selected={selectedUsers.includes(user.id)}
          onSelect={() => handleUserSelect(user.id)}
        />
      ))}
    </div>
  );
};
```

## Compound Components
```typescript
// Compound component pattern for flexible composition
interface TabsContextValue {
  activeTab: string;
  setActiveTab: (tab: string) => void;
}

const TabsContext = React.createContext<TabsContextValue | null>(null);

export const Tabs: React.FC<{ children: React.ReactNode; defaultTab?: string }> & {
  List: React.FC<{ children: React.ReactNode }>;
  Tab: React.FC<{ id: string; children: React.ReactNode }>;
  Panels: React.FC<{ children: React.ReactNode }>;
  Panel: React.FC<{ id: string; children: React.ReactNode }>;
} = ({ children, defaultTab }) => {
  const [activeTab, setActiveTab] = useState(defaultTab || '');
  
  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
};

Tabs.List = ({ children }) => (
  <div className="tabs-list" role="tablist">{children}</div>
);

Tabs.Tab = ({ id, children }) => {
  const context = useContext(TabsContext);
  if (!context) throw new Error('Tab must be used within Tabs');
  
  return (
    <button
      role="tab"
      aria-selected={context.activeTab === id}
      onClick={() => context.setActiveTab(id)}
      className={`tab ${context.activeTab === id ? 'active' : ''}`}
    >
      {children}
    </button>
  );
};

// Usage
<Tabs defaultTab="profile">
  <Tabs.List>
    <Tabs.Tab id="profile">Profile</Tabs.Tab>
    <Tabs.Tab id="settings">Settings</Tabs.Tab>
  </Tabs.List>
  <Tabs.Panels>
    <Tabs.Panel id="profile">
      <UserProfile />
    </Tabs.Panel>
    <Tabs.Panel id="settings">
      <UserSettings />
    </Tabs.Panel>
  </Tabs.Panels>
</Tabs>
```

## Higher-Order Components (HOCs) and Render Props
```typescript
// HOC for authentication
export const withAuth = <P extends object>(
  Component: React.ComponentType<P>
): React.FC<P> => {
  return (props: P) => {
    const { user, isLoading } = useAuth();
    
    if (isLoading) return <LoadingSpinner />;
    if (!user) return <Navigate to="/login" />;
    
    return <Component {...props} />;
  };
};

// Render props pattern for data fetching
interface DataFetcherProps<T> {
  url: string;
  children: (data: {
    data: T | null;
    loading: boolean;
    error: Error | null;
  }) => React.ReactNode;
}

export const DataFetcher = <T,>({ url, children }: DataFetcherProps<T>) => {
  const { data, isLoading: loading, error } = useQuery({
    queryKey: [url],
    queryFn: () => fetch(url).then(res => res.json()),
  });

  return <>{children({ data, loading, error })}</>;
};
```

# State Management

## React Query for Server State
```typescript
// services/userService.ts
export const userService = {
  getUsers: async (params?: { search?: string; limit?: number }): Promise<User[]> => {
    const query = new URLSearchParams(params as any).toString();
    const response = await fetch(`/api/users?${query}`);
    if (!response.ok) throw new Error('Failed to fetch users');
    return response.json();
  },

  createUser: async (userData: CreateUserRequest): Promise<User> => {
    const response = await fetch('/api/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(userData),
    });
    if (!response.ok) throw new Error('Failed to create user');
    return response.json();
  },

  updateUser: async ({ id, ...userData }: UpdateUserRequest): Promise<User> => {
    const response = await fetch(`/api/users/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(userData),
    });
    if (!response.ok) throw new Error('Failed to update user');
    return response.json();
  },
};

// hooks/useUsers.ts
export const useUsers = (searchTerm?: string) => {
  return useQuery({
    queryKey: ['users', searchTerm],
    queryFn: () => userService.getUsers({ search: searchTerm }),
    staleTime: 5 * 60 * 1000,
  });
};

export const useCreateUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: userService.createUser,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
    onError: (error) => {
      toast.error(`Failed to create user: ${error.message}`);
    },
  });
};
```

## Zustand for Client State
```typescript
// stores/userStore.ts
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

interface UserState {
  currentUser: User | null;
  preferences: UserPreferences;
  setCurrentUser: (user: User | null) => void;
  updatePreferences: (preferences: Partial<UserPreferences>) => void;
  logout: () => void;
}

export const useUserStore = create<UserState>()(
  devtools(
    (set) => ({
      currentUser: null,
      preferences: {
        theme: 'light',
        language: 'en',
        notifications: true,
      },
      setCurrentUser: (currentUser) => set({ currentUser }),
      updatePreferences: (newPreferences) =>
        set((state) => ({
          preferences: { ...state.preferences, ...newPreferences },
        })),
      logout: () => set({ currentUser: null }),
    }),
    { name: 'user-store' }
  )
);
```

## Context API for Component State
```typescript
// contexts/ThemeContext.tsx
interface ThemeContextValue {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = React.createContext<ThemeContextValue | null>(null);

export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ 
  children 
}) => {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');

  const toggleTheme = useCallback(() => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  }, []);

  const value = useMemo(() => ({
    theme,
    toggleTheme,
  }), [theme, toggleTheme]);

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};
```

# Form Handling

## React Hook Form Integration
```typescript
import { useForm, Controller } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';

const userSchema = yup.object({
  name: yup.string().required('Name is required').min(2, 'Name too short'),
  email: yup.string().required('Email is required').email('Invalid email'),
  age: yup.number().required('Age is required').min(18, 'Must be 18 or older'),
});

type UserFormData = yup.InferType<typeof userSchema>;

export const UserForm: React.FC<{
  initialData?: Partial<UserFormData>;
  onSubmit: (data: UserFormData) => Promise<void>;
}> = ({ initialData, onSubmit }) => {
  const {
    register,
    handleSubmit,
    control,
    formState: { errors, isSubmitting },
    reset,
  } = useForm<UserFormData>({
    resolver: yupResolver(userSchema),
    defaultValues: initialData,
  });

  const submitHandler = async (data: UserFormData) => {
    try {
      await onSubmit(data);
      reset();
    } catch (error) {
      // Error handling
    }
  };

  return (
    <form onSubmit={handleSubmit(submitHandler)} className="user-form">
      <div className="form-field">
        <label htmlFor="name">Name</label>
        <input
          id="name"
          {...register('name')}
          className={errors.name ? 'error' : ''}
        />
        {errors.name && (
          <span className="error-message">{errors.name.message}</span>
        )}
      </div>

      <div className="form-field">
        <label htmlFor="email">Email</label>
        <input
          id="email"
          type="email"
          {...register('email')}
          className={errors.email ? 'error' : ''}
        />
        {errors.email && (
          <span className="error-message">{errors.email.message}</span>
        )}
      </div>

      <div className="form-field">
        <label htmlFor="age">Age</label>
        <Controller
          name="age"
          control={control}
          render={({ field }) => (
            <input
              id="age"
              type="number"
              {...field}
              onChange={(e) => field.onChange(Number(e.target.value))}
              className={errors.age ? 'error' : ''}
            />
          )}
        />
        {errors.age && (
          <span className="error-message">{errors.age.message}</span>
        )}
      </div>

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Saving...' : 'Save User'}
      </button>
    </form>
  );
};
```

# Performance Optimization

## React.memo and Callback Optimization
```typescript
// Memoized component
interface UserCardProps {
  user: User;
  onSelect: (userId: string) => void;
  selected: boolean;
}

export const UserCard = React.memo<UserCardProps>(({ 
  user, 
  onSelect, 
  selected 
}) => {
  const handleClick = useCallback(() => {
    onSelect(user.id);
  }, [onSelect, user.id]);

  return (
    <div 
      className={`user-card ${selected ? 'selected' : ''}`}
      onClick={handleClick}
    >
      <img src={user.avatar} alt={user.name} />
      <div className="user-info">
        <h3>{user.name}</h3>
        <p>{user.email}</p>
      </div>
    </div>
  );
});

UserCard.displayName = 'UserCard';
```

## Code Splitting and Lazy Loading
```typescript
// Lazy load components
const UserDashboard = React.lazy(() => import('../pages/UserDashboard'));
const AdminPanel = React.lazy(() => import('../pages/AdminPanel'));
const Settings = React.lazy(() => import('../pages/Settings'));

// Route-based code splitting
export const AppRoutes: React.FC = () => {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/dashboard" element={<UserDashboard />} />
        <Route path="/admin" element={<AdminPanel />} />
        <Route path="/settings" element={<Settings />} />
      </Routes>
    </Suspense>
  );
};

// Component-based lazy loading
const LazyDataTable = React.lazy(() => 
  import('./DataTable').then(module => ({ default: module.DataTable }))
);

export const ReportsPage: React.FC = () => {
  const [showTable, setShowTable] = useState(false);

  return (
    <div className="reports-page">
      <h1>Reports</h1>
      <button onClick={() => setShowTable(true)}>
        Load Data Table
      </button>
      
      {showTable && (
        <Suspense fallback={<div>Loading table...</div>}>
          <LazyDataTable />
        </Suspense>
      )}
    </div>
  );
};
```

# Testing

## Component Testing with React Testing Library
```typescript
// UserCard.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { vi } from 'vitest';
import { UserCard } from './UserCard';

const mockUser = {
  id: '1',
  name: 'John Doe',
  email: 'john@example.com',
  avatar: 'https://example.com/avatar.jpg',
  createdAt: new Date(),
  updatedAt: new Date(),
};

describe('UserCard', () => {
  it('renders user information correctly', () => {
    const onSelect = vi.fn();
    
    render(
      <UserCard 
        user={mockUser} 
        onSelect={onSelect} 
        selected={false} 
      />
    );

    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
    expect(screen.getByRole('img')).toHaveAttribute('src', mockUser.avatar);
  });

  it('calls onSelect when clicked', () => {
    const onSelect = vi.fn();
    
    render(
      <UserCard 
        user={mockUser} 
        onSelect={onSelect} 
        selected={false} 
      />
    );

    fireEvent.click(screen.getByRole('button'));
    expect(onSelect).toHaveBeenCalledWith(mockUser.id);
  });

  it('applies selected styles when selected', () => {
    const onSelect = vi.fn();
    
    render(
      <UserCard 
        user={mockUser} 
        onSelect={onSelect} 
        selected={true} 
      />
    );

    expect(screen.getByRole('button')).toHaveClass('selected');
  });
});
```

## Hook Testing
```typescript
// useUserData.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { vi } from 'vitest';
import { useUserData } from './useUserData';
import { userService } from '../services/userService';

vi.mock('../services/userService');

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });

  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

describe('useUserData', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('fetches user data successfully', async () => {
    const mockUser = { id: '1', name: 'John Doe' };
    vi.mocked(userService.getUser).mockResolvedValue(mockUser);

    const { result } = renderHook(
      () => useUserData('1'),
      { wrapper: createWrapper() }
    );

    expect(result.current.loading).toBe(true);

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.user).toEqual(mockUser);
    expect(result.current.error).toBeNull();
  });

  it('handles error states', async () => {
    const mockError = new Error('Failed to fetch');
    vi.mocked(userService.getUser).mockRejectedValue(mockError);

    const { result } = renderHook(
      () => useUserData('1'),
      { wrapper: createWrapper() }
    );

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.user).toBeNull();
    expect(result.current.error).toEqual(mockError);
  });
});
```

# LLM Development Guidelines

## Code Generation Best Practices

When working with AI coding tools like Claude Code or Cursor:

### 1. Component Structure Templates
```typescript
// Template for new components
export interface [ComponentName]Props {
  // Define props here
  className?: string;
  'data-testid'?: string;
}

export const [ComponentName]: React.FC<[ComponentName]Props> = ({
  className,
  'data-testid': testId,
  ...props
}) => {
  // State and logic here
  
  return (
    <div 
      className={className}
      data-testid={testId}
    >
      {/* JSX content */}
    </div>
  );
};

export default [ComponentName];
```

### 2. Hook Patterns
```typescript
// Template for custom hooks
export interface Use[HookName]Options {
  // Options interface
}

export interface Use[HookName]Return {
  // Return type interface
}

export const use[HookName] = (
  options: Use[HookName]Options = {}
): Use[HookName]Return => {
  // Hook logic here
  
  return {
    // Return values
  };
};
```

### 3. API Service Templates
```typescript
// Template for API services
export const [entityName]Service = {
  getAll: async (params?: GetAllParams): Promise<Entity[]> => {
    // Implementation
  },
  
  getById: async (id: string): Promise<Entity> => {
    // Implementation  
  },
  
  create: async (data: CreateEntityRequest): Promise<Entity> => {
    // Implementation
  },
  
  update: async (id: string, data: UpdateEntityRequest): Promise<Entity> => {
    // Implementation
  },
  
  delete: async (id: string): Promise<void> => {
    // Implementation
  },
};
```

### 4. Consistent Error Handling
```typescript
// Error boundary for components
interface ErrorFallbackProps {
  error: Error;
  resetError: () => void;
}

const ErrorFallback: React.FC<ErrorFallbackProps> = ({ error, resetError }) => (
  <div className="error-fallback">
    <h2>Something went wrong:</h2>
    <pre>{error.message}</pre>
    <button onClick={resetError}>Try again</button>
  </div>
);

// Usage in app
export const App: React.FC = () => (
  <ErrorBoundary FallbackComponent={ErrorFallback}>
    <QueryClientProvider client={queryClient}>
      <Router>
        <AppRoutes />
      </Router>
    </QueryClientProvider>
  </ErrorBoundary>
);
```

## Build Configuration

### Vite Configuration
```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { resolve } from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
      '@components': resolve(__dirname, 'src/components'),
      '@pages': resolve(__dirname, 'src/pages'),
      '@hooks': resolve(__dirname, 'src/hooks'),
      '@services': resolve(__dirname, 'src/services'),
      '@types': resolve(__dirname, 'src/types'),
      '@utils': resolve(__dirname, 'src/utils'),
    },
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          router: ['react-router-dom'],
          query: ['@tanstack/react-query'],
        },
      },
    },
  },
  server: {
    port: 3000,
    open: true,
  },
});
```

### ESLint Configuration
```json
{
  "extends": [
    "eslint:recommended",
    "@typescript-eslint/recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended"
  ],
  "rules": {
    "react/react-in-jsx-scope": "off",
    "react/prop-types": "off",
    "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
    "prefer-const": "error",
    "no-var": "error",
    "react-hooks/exhaustive-deps": "warn"
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  }
}
```
