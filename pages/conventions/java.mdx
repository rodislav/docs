---
title: 'Java'
description: 'Coding conventions for Java programming language'
---

<Info>
  **Note**: This document outlines the coding conventions for Java programming language, including object oriented and functional paradigms. This file can be used for code generation as a master prompt or just contextual file when working with LLM tools like Claude Code and Cursor.
</Info>

# General

- Use latest stable version of Java (prefer Java 21 LTS or later).
- Enable preview features cautiously and only for non-production environments.
- Use `--enable-preview` flag when experimenting with preview features.

- Do not use fully qualified names in the code, use import statements instead. If not possible, use the fully qualified name only in the declaration, not in the usage.
- Organize imports: static imports first, then java.*, javax.*, then third-party, then application packages.
- Remove unused imports and use IDE auto-formatting.

- Use **PascalCase** for:
    - file names.
    - interface names.
    - enums.

- Use **camelCase** for:
    - Method names.
    - Variable names.
    - Parameter names.
    - Field names.

- Use **UPPER CASE** for:
    - Constants.
    - Enum constants.

- Use lower case for:
    - package names.

- Use meaningful names that clearly describe the purpose of the element:
    - For packages, use a reverse domain name followed by the project name (e.g., `com.example.project`).
    - For modules, use a descriptive name that indicates the module's functionality.
    - For files, use the same name as the class or interface they contain.
    - For constants, use names that indicate their purpose or value.

- Do not use:
    - Underscores in names.
    - Abbreviations in names.
    - Single letter names (except for loop variables).
    - Suffixes like "Interface" for naming an Interface, "Class" or "Impl" or "Implementation" for naming a class.

# Code formatting

- Use UTF-8 encoding.
- Use "4 spaces" for indentation.
- Maximum line length: 120 characters.
- Use consistent formatting with tools like Google Java Format or Prettier for Java.

# Class design

- Use nouns or noun phrases, and it shall describe the intent.
- Use constructor-based dependency injection.
- Each class must have a single responsibility.
- Use abstract classes for shared behavior.
- Use interfaces to define contracts if multiple implementations exist.
- Limit inheritance to a single level.
- Favor composition over inheritance.
- Use `final` for classes that should not be extended.
- Favor stateless classes, unless it is a stateful class that represents a domain entity or value object.
- Use one file for one class.

# Interface design

- Use one file for one interface.


# Method design

- Use `camelCase` for method names and variable names.
- Use descriptive names for methods that indicate their purpose, use verbs or verb phrases.
- Keep methods short and focused on a single task.
- Use `@Override` annotation when overriding methods.
- Use `@Deprecated` annotation for methods that should no longer be used.
- Use `@FunctionalInterface` annotation for functional interfaces.
- Keep method parameters to a minimum, ideally no more than 3.
- Use `var` for local variables.
- Use `this` keyword to refer to instance variables when necessary to avoid ambiguity.
- Use Optional for method return types when a value may be absent, instead of returning `null`.
- Use `@Nullable` and `@NonNull` annotations to indicate nullability of method parameters.
- Favor method chaining for fluent APIs, but ensure it remains readable.
- Use "one-liner" lambda expressions for simple operations, or extract the complex logic to a method and use it as a lambda call.
- Avoid static methods and variables unless they are utility methods or constants.
- Favor stateless methods over stateful methods.

# Loops and conditionals

- Limit the use of loops to simple iterations, no more than two levels of depth.
- Use "null-safe" checks for objects before accessing their properties or methods.
- When a `if` statement has more than one branch, use a helper function with a meaningful name to encapsulate the logic of decision.

# Code documentation

- Write comments in Javadoc format, sparingly, only for complex code.
- Use `@param`, `@return`, and `@throws` tags in Javadoc comments to document method parameters, return values, and exceptions.
- Use `@see` tag to reference related classes or methods.
- Use `@deprecated` tag to indicate deprecated methods or classes.
- Keep it concise and relevant, avoid redundant information.

# Testing

- Use JUnit for unit testing.
- Use descriptive names for test methods that indicate the purpose of the test.
- Use `@Test` annotation for test methods.
- Use `@BeforeEach` and `@AfterEach` annotations for setup and teardown methods.
- Use `@ParameterizedTest` for parameterized tests.
- Use `@Nested` for grouping related tests.
- Use `assert` methods from JUnit for assertions.
- Use `Mockito` for mocking dependencies in tests.
- One "unit test" per public method, and each test should be independent of others.
- Write separated tests for both positive and negative scenarios.
- Do not test private methods directly; test them through public methods.

# Exception handling

- Use exceptions for error handling, not for control flow.
- Use checked exceptions for recoverable conditions and unchecked exceptions for the rest.
- Use specific exception types instead of generic ones.
- Use `try-catch` blocks for exception handling, and avoid catching generic exceptions.
- Use `finally` block for cleanup code that must always execute.
- Use `throw` statement to throw exceptions, and provide meaningful messages.
- Never catch `Throwable` or `Exception` unless absolutely necessary.
- Use custom exception classes for domain-specific errors.
- Do not use the word "error" in exception names, unless it is a business error and not a technical error.

# Multithreading

- Favor Virtual Threads (Project Loom) for concurrency when available.
- Use `ExecutorService` for managing threads instead of creating threads manually.
- Use `synchronized` keyword or `java.util.concurrent` package for thread safety.
- Use `volatile` keyword for variables that may be accessed by multiple threads.
- Avoid using `Thread.stop()` or `Thread.suspend()` methods as they are unsafe.
- Avoid using shared mutable state between threads.
- Avoid using `ThreadLocal` unless absolutely necessary, as it can lead to memory leaks.
- Avoid using `Thread` class directly; prefer using `Runnable` or `Callable` interfaces.

# Modern Java Features

## Records
- Do not usese records
- Use lombok.

## Sealed Classes (Java 17+)
Use sealed classes for controlled inheritance:

```java
public sealed interface PaymentMethod 
    permits CreditCard, BankTransfer, DigitalWallet {
}

public final class CreditCard implements PaymentMethod {
    private final String number;
    private final String expiryDate;
    // ...
}

public final class BankTransfer implements PaymentMethod {
    private final String accountNumber;
    private final String routingNumber;
    // ...
}

public non-sealed class DigitalWallet implements PaymentMethod {
    // Allows further extension
}
```

## Pattern Matching (Java 17+)
Use pattern matching for instanceof and switch expressions:

```java
// Pattern matching with instanceof
public String processPayment(PaymentMethod payment) {
    return switch (payment) {
        case CreditCard(var number, var expiry) -> 
            "Processing credit card ending in " + number.substring(number.length() - 4);
        case BankTransfer(var account, var routing) -> 
            "Processing bank transfer from account " + account;
        case DigitalWallet wallet -> 
            "Processing digital wallet: " + wallet.getProviderName();
    };
}

// Guard conditions in pattern matching
public BigDecimal calculateDiscount(Customer customer, BigDecimal amount) {
    return switch (customer) {
        case PremiumCustomer(var tier) when tier.equals("GOLD") -> 
            amount.multiply(new BigDecimal("0.15"));
        case PremiumCustomer(var tier) when tier.equals("SILVER") -> 
            amount.multiply(new BigDecimal("0.10"));
        case RegularCustomer(var yearsActive) when yearsActive >= 5 -> 
            amount.multiply(new BigDecimal("0.05"));
        default -> BigDecimal.ZERO;
    };
}
```

## Text Blocks (Java 15+)
Use text blocks for multiline strings:

```java
// Good: SQL queries
private static final String FIND_USER_QUERY = """
    SELECT u.id, u.name, u.email, u.created_at
    FROM users u
    WHERE u.active = true
      AND u.created_at >= ?
    ORDER BY u.created_at DESC
    """;

// Good: JSON templates
private static final String ERROR_RESPONSE_TEMPLATE = """
    {
        "error": {
            "code": "%s",
            "message": "%s",
            "timestamp": "%s"
        }
    }
    """;
```






# LLM Development Guidelines

## Code Generation Best Practices

When working with AI coding tools like Claude Code or Cursor:

### 2. Use Builder Pattern for Complex Objects
```java
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private Long id;
    private String name;
    private String email;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    @Builder.Default
    private boolean active = true;
}
```

### 4. Testing Patterns
```java
@SpringBootTest
@TestPropertySource(locations = "classpath:application-test.properties")
class UserServiceTest {
    
    @MockBean
    private UserRepository userRepository;
    
    @Autowired
    private UserService userService;
    
    @Test
    void createUser_WithValidData_ReturnsUser() {
        // Given
        var request = new CreateUserRequest("John Doe", "john@example.com", null);
        var expectedUser = User.builder()
            .id(1L)
            .name("John Doe")
            .email("john@example.com")
            .build();
            
        when(userRepository.save(any(User.class))).thenReturn(expectedUser);
        
        // When
        var result = userService.createUser(request);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getName()).isEqualTo("John Doe");
        assertThat(result.getEmail()).isEqualTo("john@example.com");
    }
}
```

